---
title: Introduction
description: A powerful library for building type-safe APIs with context management
---

import { Cards, Card } from "fumadocs-ui/components/card";

# DeesseJS Functions

**DeesseJS Functions** is a powerful TypeScript library for building type-safe APIs with context management. Following a major architectural overhaul, the library now features a simplified API that removes complex type-level programming while maintaining full type safety.

## What's New? ðŸš€

- **âœ¨ Native API**: `query` and `mutation` are built-in - no extensions required
- **âš¡ Lightning Fast**: No more "Type instantiation is excessively deep" errors
- **ðŸŽ¯ Simple Types**: Standard TypeScript generics - no HKT complexity
- **ðŸ”’ Type Safe**: Full end-to-end type safety with Zod validation
- **ðŸ“¦ Zero Config**: Get started in seconds, not hours

## Installation

```bash
npm install @deessejs/functions
# or
yarn add @deessejs/functions
# or
pnpm add @deessejs/functions
```

## Quick Start

### The New Simplified Way

```ts
import { defineContext, success } from "@deessejs/functions";
import z from "zod";

// 1. Define your context ONCE (single source of truth)
const { t, createAPI } = defineContext<{
  userId: string;
  database: any;
}>({
  userId: "user-123",
  database: myDatabase
});

// 2. Define queries (read operations)
const getUser = t.query({
  args: z.object({
    id: z.number(),
  }),
  handler: async (ctx, args) => {
    // Note: ctx comes BEFORE args
    return success({
      id: args.id,
      requestedBy: ctx.userId,
    });
  },
});

// 3. Define mutations (write operations)
const createUser = t.mutation({
  args: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    const user = ctx.database.users.create(args);
    return success(user);
  },
});

// 4. Create the API (no context needed here!)
const api = createAPI({ getUser, createUser });

// 5. Call your endpoints
async function main() {
  const result = await api.getUser({ id: 123 });

  if (result.ok) {
    console.log("User:", result.value);
  } else {
    console.error("Error:", result.error);
  }
}
```

## Key Concepts

### Context

Context is the data available to all your handlers:

```ts
const { t, createAPI } = defineContext<{
  userId: string;
  database: Database;
  logger: Logger;
}>({
  userId: "user-123",
  database: myDatabase,
  logger: myLogger
});
```

### Queries

Queries are read-only operations:

```ts
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success({ id: args.id, name: "User" });
  },
});
```

### Mutations

Mutations are write operations:

```ts
const createUser = t.mutation({
  args: z.object({ name: z.string() }),
  handler: async (ctx, args) => {
    return success({ id: 1, name: args.name });
  },
});
```

### Router

Organize endpoints logically:

```ts
const api = createAPI({
  users: t.router({
    profile: t.router({
      get: t.query({ ... }),
      update: t.mutation({ ... }),
    }),
    settings: t.query({ ... }),
  }),
  posts: t.router({
    get: t.query({ ... }),
    list: t.query({ ... }),
  }),
});

// Usage
await api.users.profile.get({ id: 1 });
await api.users.settings.update({});
```

## Documentation

<Cards>
  <Card title="Getting Started" href="/docs/getting-started" />
  <Card title="Context" href="/docs/context" />
  <Card title="Queries & Mutations" href="/docs/queries-mutations" />
  <Card title="Router" href="/docs/router" />
  <Card title="Lifecycle Hooks" href="/docs/lifecycle-hooks" />
  <Card title="Error Handling" href="/docs/error-handling" />
  <Card title="Type System" href="/docs/types/result" />
  <Card title="Advanced Features" href="/docs/advanced" />
  <Card title="Migration Guide" href="/docs/migration" />
</Cards>
