---
title: Advanced Features
description: Overview of advanced patterns and features
---

import { Cards, Card } from "fumadocs-ui/components/card";

# Advanced Features

Explore advanced patterns and features for building sophisticated APIs with DeesseJS Functions.

## Features Overview

<Cards>
  <Card title="Retry" href="/docs/retry" />
  <Card title="Cache Invalidation Stream" href="/docs/cache-stream" />
  <Card title="Command Aliases" href="/docs/command-aliases" />
  <Card title="Standalone Operations" href="/docs/standalone-operations" />
</Cards>

## Retry

Automatic retry logic with configurable backoff strategies for resilient operations.

**Features:**
- Configurable retry attempts and delays
- Exponential backoff
- Custom retry predicates
- Pre-configured strategies (quick, standard, aggressive, network, idempotent)
- Retry with Outcome types
- Logging and monitoring

**When to use:**
- Network operations that may fail temporarily
- External API calls
- Database connections
- Any operation that benefits from automatic retries

→ [Learn more about Retry](/docs/retry)

## Cache Invalidation Stream

Real-time cache coordination and invalidation across your application.

**Features:**
- Subscribe to cache changes
- Tag-based invalidation
- Mutation notifications
- Event history and statistics
- Stream utilities for key management

**When to use:**
- Real-time applications
- Multi-region cache synchronization
- Distributed cache coordination
- Cache warming strategies

→ [Learn more about Cache Stream](/docs/cache-stream)

## Command Aliases

Provide multiple names for the same operation for backward compatibility and API evolution.

**Features:**
- Multiple endpoint names
- Backward compatibility
- API versioning
- Semantic variations
- Deprecation strategies

**When to use:**
- Maintaining old API versions
- Gradual migration
- Different naming conventions
- Domain-specific terminology

→ [Learn more about Command Aliases](/docs/command-aliases)

## Standalone Operations

Use queries and mutations outside the API builder for maximum flexibility.

**Features:**
- Testing in isolation
- Operation composition
- Conditional execution
- Dynamic context
- Custom middleware

**When to use:**
- Testing individual operations
- Composing multiple operations
- Dynamic context switching
- Building custom abstractions

→ [Learn more about Standalone Operations](/docs/standalone-operations)

## Common Patterns

### Request Scoping

Create different API instances for different requests:

```ts
function createAPIForRequest(request: Request) {
  const { t, createAPI } = defineContext({
    requestId: crypto.randomUUID(),
    userId: await authenticateUser(request),
  });

  return createAPI({
    // ... endpoints
  });
}
```

### Multi-Tenancy

Build multi-tenant applications with isolated contexts:

```ts
function createTenantAPI(tenant: Tenant) {
  const { t, createAPI } = defineContext({
    tenantId: tenant.id,
    database: createTenantDatabase(tenant.id),
  });

  return createAPI({
    // ... endpoints
  });
}
```

### Event Sourcing

Emit events for state changes:

```ts
const createUser = t.mutation({
  handler: async (ctx, args) => {
    const user = await ctx.db.users.create(args);

    eventStream.notifyMutation(
      "UserCreated",
      successOutcome({ user, timestamp: Date.now() })
    );

    return success(user);
  },
});
```

### Batch Operations

Process multiple operations efficiently:

```ts
const batchCreateUsers = t.mutation({
  args: z.object({
    users: z.array(z.object({
      name: z.string(),
      email: z.string().email(),
    })),
  }),
  handler: async (ctx, args) => {
    const results = await Promise.allSettled(
      args.users.map(user => ctx.db.users.create(user))
    );

    const created = results
      .filter(r => r.status === "fulfilled")
      .map(r => r.value);

    const failed = results
      .filter(r => r.status === "rejected")
      .map(r => r.reason);

    return success({ created, failed });
  },
});
```

### Atomic Operations

Use transactions for data consistency:

```ts
const transferFunds = t.mutation({
  handler: async (ctx, args) => {
    return await ctx.db.transaction(async (trx) => {
      await trx.accounts.debit(args.fromUserId, args.amount);
      await trx.accounts.credit(args.toUserId, args.amount);
      return success({ transferred: true });
    });
  },
});
```

## Performance Tips

### 1. Use Caching Strategically

```ts
const getUser = t.query({
  handler: async (ctx, args) => {
    return success(await ctx.cache.getOrSet(
      `user:${args.id}`,
      () => ctx.db.users.find(args.id),
      { ttl: 60000 }
    ));
  },
});
```

### 2. Batch Database Queries

```ts
const getUsers = t.query({
  handler: async (ctx, args) => {
    // Good: single query
    const users = await ctx.db.users.findByIds(args.ids);

    // Avoid: multiple queries
    // const users = await Promise.all(
    //   args.ids.map(id => ctx.db.users.find(id))
    // );

    return success(users);
  },
});
```

### 3. Use Parallel Operations

```ts
const getUserWithData = t.query({
  handler: async (ctx, args) => {
    const [user, posts, settings] = await Promise.all([
      ctx.db.users.find(args.id),
      ctx.db.posts.findByUser(args.id),
      ctx.db.settings.findByUser(args.id),
    ]);

    return success({ user, posts, settings });
  },
});
```

## Related Documentation

- [Error Handling](/docs/error-handling) - Advanced error patterns
- [Lifecycle Hooks](/docs/lifecycle-hooks) - Middleware and hooks
- [Type System](/docs/types/result) - Type utilities
