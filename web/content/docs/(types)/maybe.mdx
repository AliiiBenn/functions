---
title: Maybe
description: A type for optional values that may or may not exist
---

# Maybe Type

The `Maybe<T>` type represents an optional value that may or may not exist. It's a type-safe alternative to `null` and `undefined`.

## Overview

```ts
type Maybe<T> = Some<T> | None;

interface Some<T> {
  _tag: "Some";
  value: T;
}

interface None {
  _tag: "None";
}
```

## Creating Maybes

### Some

```ts
import { some } from "@deessejs/functions";

const maybeUser = some({ id: 1, name: "Alice" });
// Maybe<User>
```

### None

```ts
import { none } from "@deessejs/functions";

const emptyUser = none();
// Maybe<never>
```

### From Nullable

```ts
import { some, none, fromNullable } from "@deessejs/functions";

const user = await db.users.find(id);
const maybeUser = fromNullable(user);
// Maybe<User>
```

## Using Maybes

### Pattern Matching

```ts
import { some, none } from "@deessejs/functions";

const maybeUser = some({ id: 1, name: "Alice" });

if (maybeUser._tag === "Some") {
  // TypeScript knows value exists
  console.log(maybeUser.value.name); // string
} else {
  console.log("No user");
}
```

### map

Transform the value if it exists:

```ts
const maybeUser = some({ id: 1, name: "Alice" });

const maybeName = maybeUser.map(user => user.name);
// Maybe<string>
```

### mapNone

Provide a default value:

```ts
const maybeUser = some({ id: 1, name: "Alice" });

const name = maybeUser.mapNone(() => "Unknown");
// "Alice"
```

### unwrapOr

Get the value or a default:

```ts
const maybeUser = some({ id: 1, name: "Alice" });

const user = maybeUser.unwrapOr({ id: 0, name: "Unknown" });
// { id: 1, name: "Alice" }
```

### unwrapOrElse

Get the value or compute a default:

```ts
const maybeUser = none();

const user = maybeUser.unwrapOrElse(() => ({ id: 0, name: "Unknown" }));
// { id: 0, name: "Unknown" }
```

## Examples

### Database Query

```ts
import { fromNullable, some, none } from "@deessejs/functions";

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.db.users.find(args.id);
    const maybeUser = fromNullable(user);

    return maybeUser.match({
      Some: (user) => success(user),
      None: () => failure(
        exception({ name: "NotFound", message: "User not found" })
      ),
    });
  },
});
```

### Configuration

```ts
interface Config {
  apiUrl: string;
  timeout: number;
  debug: boolean;
}

const defaultConfig: Config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  debug: false,
};

function loadConfig(): Maybe<Config> {
  const config = readConfigFile();
  return fromNullable(config);
}

const config = loadConfig().unwrapOr(defaultConfig);
```

### Optional Parameters

```ts
function greet(maybeName: Maybe<string>): string {
  return maybeName.match({
    Some: (name) => `Hello, ${name}!`,
    None: () => "Hello, stranger!",
  });
}

greet(some("Alice")); // "Hello, Alice!"
greet(none()); // "Hello, stranger!"
```

## Best Practices

<Callout type="tip">
Use `Maybe` instead of `null` or `undefined` for better type safety.
</Callout>

```ts
// Good
function findUser(id: number): Maybe<User> {
  const user = db.users.find(id);
  return fromNullable(user);
}

// Avoid
function findUser(id: number): User | null {
  return db.users.find(id) || null;
}
```

<Callout type="warn">
Always check `_tag` before accessing `value`.
</Callout>

```ts
// Good
if (maybe._tag === "Some") {
  console.log(maybe.value);
}

// Bad - may throw at runtime
console.log(maybe.value); // Error if maybe is None
```

## Related Types

- [Result](/docs/types/result) - For operations that can fail
- [Unit](/docs/types/unit) - For functions with no meaningful return
- [Try](/docs/types/try) - For exception handling
