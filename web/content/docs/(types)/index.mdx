---
title: Type System
description: Overview of the type system utilities
---

# Type System

DeesseJS Functions provides a comprehensive type system for building type-safe APIs. These utilities help you handle errors, optional values, and async operations with full type safety.

## Core Types

### Result

The `Result<T, E>` type represents an operation that can either succeed with a value or fail with an error.

```ts
type Result<T, E> =
  | { ok: true; value: T }
  | { ok: false; error: E };
```

**Use when:** Operations can fail with known error types.

- [Result Documentation](/docs/types/result)

### AsyncResult

The `AsyncResult<T, E>` type is an async version of `Result`.

```ts
type AsyncResult<T, E> = Promise<Result<T, E>>;
```

**Use when:** Async operations can fail with known error types.

- [AsyncResult Documentation](/docs/types/async-result)

### Maybe

The `Maybe<T>` type represents an optional value.

```ts
type Maybe<T> = Some<T> | None;
```

**Use when:** Values may or may not exist (type-safe alternative to `null`/`undefined`).

- [Maybe Documentation](/docs/types/maybe)

### Unit

The `Unit` type represents functions with no meaningful return value.

```ts
type Unit = undefined;
```

**Use when:** Functions perform side effects but don't return a value.

- [Unit Documentation](/docs/types/unit)

## When to Use Which Type?

### Decision Tree

```
Is your operation async?
├─ Yes → Use AsyncResult<T, E>
└─ No
   ├─ Can it fail with specific errors?
   │  ├─ Yes → Use Result<T, E>
   │  └─ No
   │     ├─ Is the value optional?
   │     │  ├─ Yes → Use Maybe<T>
   │     │  └─ No → Use T directly
   └─ Does it perform side effects only?
      └─ Yes → Use Unit
```

### Examples

```ts
// Async operation that can fail
async function fetchUser(id: number): AsyncResult<User, Exception> {
  const user = await db.users.find(id);
  if (!user) {
    return failure(exception({ name: "NotFound", message: "Not found" }));
  }
  return success(user);
}

// Sync operation that can fail
function parseEmail(email: string): Result<Email, Exception> {
  if (isValidEmail(email)) {
    return success(new Email(email));
  }
  return failure(exception({ name: "InvalidEmail", message: "Invalid" }));
}

// Optional value
function findUser(id: number): Maybe<User> {
  const user = db.users.find(id);
  return fromNullable(user);
}

// Side effect only
function logEvent(event: Event): Unit {
  console.log(event);
}
```

## Creating Values

### Success/Some

```ts
import { success, some } from "@deessejs/functions";

const result = success({ id: 1, name: "Alice" }); // Result<User, Exception>
const maybe = some({ id: 1, name: "Alice" });    // Maybe<User>
```

### Failure/None

```ts
import { failure, exception, none } from "@deessejs/functions";

const error = exception({ name: "NotFound", message: "Not found" });
const result = failure(error); // Result<never, Exception>
const empty = none();          // Maybe<never>
```

## Utility Functions

### map

Transform the success value:

```ts
const result = success({ id: 1, name: "Alice" });
const name = result.map(user => user.name); // Result<string, Exception>

const maybe = some({ id: 1, name: "Alice" });
const name = maybe.map(user => user.name); // Maybe<string>
```

### chain

Chain operations that return Results:

```ts
const result = await api.getUser({ id: 1 });
const posts = result.chain(async (user) => {
  return await api.getPosts({ userId: user.id });
});
```

### unwrapOr

Get the value or a default:

```ts
const result = await api.getUser({ id: 1 });
const user = result.unwrapOr({ id: 0, name: "Unknown" });

const maybe = fromNullable(db.users.find(1));
const user = maybe.unwrapOr({ id: 0, name: "Unknown" });
```

## Best Practices

<Callout type="tip">
Use `Result` for operations that can fail with specific errors, and `Maybe` for optional values.
</Callout>

```ts
// Good - Result for failures
function fetchUser(id: number): Result<User, Exception> {
  const user = db.users.find(id);
  if (!user) {
    return failure(exception({ name: "NotFound", message: "User not found" }));
  }
  return success(user);
}

// Good - Maybe for optional values
function findUserPhoto(user: User): Maybe<Photo> {
  return fromNullable(user.photo);
}
```

<Callout type="warn">
Avoid mixing `null`/`undefined` with `Maybe`. Use `fromNullable()` to convert.
</Callout>

```ts
// Good - convert nullable to Maybe
function findUser(id: number): Maybe<User> {
  const user = db.users.find(id); // User | undefined
  return fromNullable(user);
}

// Avoid - returning null/undefined directly
function findUser(id: number): User | null {
  return db.users.find(id) || null;
}
```

## Related Documentation

- [Error Handling](/docs/error-handling) - Working with exceptions
- [Getting Started](/docs/getting-started) - Introduction to the library
