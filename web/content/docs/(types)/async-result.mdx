---
title: AsyncResult
description: A type for asynchronous operations that can succeed or fail
---

# AsyncResult Type

The `AsyncResult<T, E>` type represents an asynchronous operation that can either succeed with a value or fail with an error.

## Overview

```ts
type AsyncResult<T, E> = Promise<Result<T, E>>;
```

It's essentially a `Promise` that resolves to a `Result` type.

## Usage

### Creating AsyncResults

```ts
import { success, failure, exception } from "@deessejs/functions";

async function fetchUser(id: number): AsyncResult<User, Exception> {
  try {
    const user = await db.users.find(id);
    if (user) {
      return success(user);
    }
    return failure(
      exception({ name: "NotFound", message: "User not found" })
    );
  } catch (error) {
    return failure(
      exception({ name: "DatabaseError", message: error.message })
    );
  }
}
```

### Using AsyncResults

```ts
const result = await fetchUser(1);

if (result.ok) {
  console.log("User:", result.value);
} else {
  console.error("Error:", result.error.message);
}
```

## Examples

### Parallel Fetching

```ts
const getUserWithPosts = t.query({
  args: z.object({ userId: z.number() }),
  handler: async (ctx, args) => {
    const [userResult, postsResult] = await Promise.all([
      ctx.db.users.find(args.userId),
      ctx.db.posts.findByUser(args.userId),
    ]);

    if (!userResult) {
      return failure(
        exception({ name: "NotFound", message: "User not found" })
      );
    }

    return success({
      user: userResult,
      posts: postsResult,
    });
  },
});
```

### Sequential Operations

```ts
const createUserWithEmail = t.mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    // Create user
    const userResult = await ctx.db.users.create(args);
    if (!userResult.ok) {
      return userResult;
    }

    // Send email
    const emailResult = await ctx.email.send({
      to: args.email,
      template: "welcome",
    });
    if (!emailResult.ok) {
      return emailResult;
    }

    return success(userResult.value);
  },
});
```

### Retry Logic

```ts
async function fetchWithRetry(
  id: number,
  maxAttempts = 3
): AsyncResult<User, Exception> {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const result = await fetchUser(id);

    if (result.ok) {
      return result;
    }

    if (attempt === maxAttempts) {
      return result;
    }

    // Wait before retry
    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
  }

  return failure(
    exception({ name: "MaxRetriesExceeded", message: "Max retries exceeded" })
  );
}
```

## Related Types

- [Result](/docs/types/result) - Synchronous version
- [Try](/docs/types/try) - For exception handling
- [Outcome](/docs/types/outcome) - For complex failure scenarios
